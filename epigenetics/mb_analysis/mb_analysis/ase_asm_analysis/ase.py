import pandas as pd
import numpy as np

from nanoepitools.annotations.annotations import GFFFeature, GFFAnnotationsReader
from nanoepitools.math import fdr_from_pvals

from mb_analysis.ase_asm_analysis.phased_vcf import PhasedVCF


def create_gene_list(features):
    return [f.id.split(":")[1] for f in features]


def get_genes_for_variant(variant_chrom, variant_pos, gff: GFFAnnotationsReader):
    chrom_feature: GFFFeature = gff.chromosomes[variant_chrom]
    return create_gene_list(chrom_feature.get_in_range(variant_pos, variant_pos, max_recursion=0))


def get_genes_for_region(region_chrom: str, start: int, end: int, gff: GFFAnnotationsReader):
    chrom_feature: GFFFeature = gff.chromosomes[region_chrom]
    return create_gene_list(chrom_feature.get_in_range(start, end, max_recursion=0))


def get_nearest_gene_for_variant(variant_chrom, variant_pos, gff: GFFAnnotationsReader):
    chrom_feature: GFFFeature = gff.chromosomes[variant_chrom]
    gene, dist = chrom_feature.get_nearest_feature(variant_pos, variant_pos, max_recursion=0)
    return gene.id.split(":")[1], dist


def get_nearest_gene_for_region(region_chrom: str, start: int, end: int, gff: GFFAnnotationsReader):
    chrom_feature: GFFFeature = gff.chromosomes[region_chrom]
    gene, dist = chrom_feature.get_nearest_feature(start, end, max_recursion=0)
    return gene.id.split(":")[1], dist


class ASE:
    def __init__(self, wasp_ase_file: str, not_wasp_format=False):
        # parameter not_wasp_format tells us to parsed the file generated by MJB before christmas 2021,
        # which no longer uses wasp
        
        self.wasp_ase_file = wasp_ase_file
        self.not_wasp_format = not_wasp_format
        
        # Loaded in load()
        self.ase_df: pd.DataFrame = None
    
    def load(self, *args, **kwargs):
        if self.not_wasp_format:
            return self._load_not_wasp(*args, **kwargs)
        else:
            return self._load_wasp(*args, **kwargs)
    
    def _load(
        self,
        col_names_types,
        pval_thres=0.05,
        load_gene_annotation=False,
        compute_fdr=False,
    ):
        self.ase_df = pd.read_csv(
            self.wasp_ase_file,
            sep="\t",
            usecols=col_names_types.keys(),
            dtype={k: v for k, (_, v) in col_names_types.items()},
        ).rename({k: v for k, (v, _) in col_names_types.items()}, axis=1)
        self.ase_df = self.ase_df.set_index(["chr", "pos", "ALT"], drop=True)
        if pval_thres is not None:
            if compute_fdr:
                if load_gene_annotation:
                    print("Warning: Reducing to only 1 row per gene (or else FDR calculation wouldn't worK)")
                    self.ase_df = self.ase_df.reset_index().groupby("geneid").agg(lambda x: next(iter(x)))
                    self.ase_df["fdr"] = fdr_from_pvals(self.ase_df["pval"])
                    self.ase_df = self.ase_df.reset_index(drop=False).set_index(["chr", "pos", "ALT"], drop=True)
                self.ase_df = self.ase_df.loc[self.ase_df["fdr"] < pval_thres]
            else:
                self.ase_df = self.ase_df.loc[self.ase_df["pval"] < pval_thres]
    
    def _load_wasp(self, load_range=False, load_exon_annotation=False, load_gene_annotation=False, **kwargs):
        col_names_types = {
            "TEST.SNP.CHROM": ("chr", str),
            "TEST.SNP.POS": ("pos", int),
            "TEST.SNP.ALT.ALLELE": ("ALT", str),
            "P.VALUE": ("pval", float),
            "REF.AS.READ.COUNT": ("ref_count", int),
            "ALT.AS.READ.COUNT": ("alt_count", int),
        }
        if load_range:
            col_names_types.update(
                {
                    "REGION.START": ("start", int),
                    "REGION.END": ("end", int),
                }
            )
        if load_exon_annotation:
            col_names_types.update({"Exon_ID": ("exonid", str)})
        if load_gene_annotation:
            col_names_types.update({"Gene_ID": ("geneid", str)})
        self._load(col_names_types, load_gene_annotation=load_gene_annotation, **kwargs)
    
    def _load_not_wasp(self, load_exon_annotation=False, load_gene_annotation=False, **kwargs):
        col_names_types = {
            "CHROM": ("chr", str),
            "TEST.SNP.POS": ("pos", int),
            "TEST.SNP.ALT.ALLELE": ("ALT", str),
            "P.VALUE.P1": ("pval", float),
            "REGION.SNP.REF.COUNT.P1": ("ref_count", int),
            "REGION.SNP.ALT.COUNT.P1": ("alt_count", int),
        }
        if load_exon_annotation:
            col_names_types.update({"Exon_ID": ("exonid", str)})
        if load_gene_annotation:
            col_names_types.update({"Gene_ID": ("geneid", str)})
        self._load(col_names_types, load_gene_annotation=load_gene_annotation, **kwargs)
    
    def copy(self):
        ret = ASE(self.wasp_ase_file)
        ret.wasp_ase_file = self.wasp_ase_file
        ret.ase_df = self.ase_df.copy()
        return ret
    
    def assign_counts_to_hp(self, vcf: PhasedVCF, sample: str):
        self.ase_df = self.ase_df.merge(vcf.vcf_df[f"hp_{sample}"], how="left", left_index=True, right_index=True)
        self.ase_df = self.ase_df.rename({f"hp_{sample}": "hp"}, axis=1)
        
        # Drop unphased
        self.ase_df = self.ase_df.loc[~pd.isnull(self.ase_df["hp"])]
        
        self.ase_df["hp1"] = np.array(
            self.ase_df.apply(lambda x: x["alt_count"] if x["hp"] == 1 else x["ref_count"], axis=1).astype(int)
        )
        self.ase_df["hp2"] = np.array(
            self.ase_df.apply(lambda x: x["alt_count"] if x["hp"] == 2 else x["ref_count"], axis=1).astype(int)
        )
    
    def compute_hp1_ratio(self, exonwise=False):
        self.ase_df["hp1_ratio"] = self.ase_df["hp1"] / (self.ase_df["hp1"] + self.ase_df["hp2"])
    
    def annotate_gene(self, gff: GFFAnnotationsReader, mode="in_gene_body"):
        if mode == "in_gene_body":
            self.ase_df["genes"] = self.ase_df.apply(
                lambda x: ",".join(get_genes_for_variant(*(x.name[:2]), gff)), axis=1
            )
        elif mode == "nearest":
            self.ase_df[["nearest_gene", "nearest_gene_dist"]] = self.ase_df.apply(
                lambda x: get_nearest_gene_for_variant(*(x.name[:2]), gff), axis=1, result_type="expand"
            )
        elif mode == "region_in_gene_body":
            self.ase_df["genes"] = self.ase_df.apply(
                lambda x: ",".join(get_genes_for_region(x.name[0], x["start"], x["end"], gff)), axis=1
            )
        elif mode == "region_nearest":
            self.ase_df["genes"] = self.ase_df.apply(
                lambda x: get_nearest_gene_for_region(x.name[0], x["start"], x["end"], gff), axis=1
            )
    
    def aggregate_duplicates(self):
        self.ase_df = self.ase_df.groupby(self.ase_df.index).agg({"pval": min, "ref_count": sum, "alt_count": sum})
        # Unfortunately the grouping reduces the index to tuple
        # instead of multiindex, so you can restore the index like this:
        self.ase_df.index = pd.MultiIndex.from_tuples(self.ase_df.index, names=["chr", "pos", "ALT"])
    
    def get_per_exon_hp_ratio(self):
        reduced_df = self.ase_df[["exonid", "hp1", "hp2"]].groupby("exonid").sum()
        reduced_df["geneid"] = reduced_df.index.map(lambda x: x.split("_")[0])
        reduced_df["hp1_ratio"] = reduced_df["hp1"] / (reduced_df["hp1"] + reduced_df["hp2"])
        return reduced_df
    
    def get_per_gene_hp_ratio(self):
        reduced_df = self.ase_df[["geneid", "hp1", "hp2"]].groupby("geneid").sum()
        reduced_df["geneid"] = reduced_df.index.map(lambda x: x.split("_")[0])
        reduced_df["hp1_ratio"] = reduced_df["hp1"] / (reduced_df["hp1"] + reduced_df["hp2"])
        return reduced_df
